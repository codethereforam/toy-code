前言                                                                            4
第1章 并发编程的挑战                                                            8
1.1 上下文切换                                                                  9
1.1 上下文切换                                                                  9
1.1.1 多线程一定快吗                                                            10
1.1.1 多线程一定快吗                                                            10
1.1.2 测试上下文切换次数和时长                                                  12
1.1.2 测试上下文切换次数和时长                                                  12
1.1.3 如何减少上下文切换                                                        13
1.1.3 如何减少上下文切换                                                        13
1.1.4 减少上下文切换实战                                                        14
1.1.4 减少上下文切换实战                                                        14
1.2 死锁                                                                        16
1.2 死锁                                                                        16
1.3 资源限制的挑战                                                              19
1.3 资源限制的挑战                                                              19
1.4 本章小结                                                                    21
1.4 本章小结                                                                    21
第2章 Java并发机制的底层实现原理                                                22
2.1 volatile的应用                                                              23
2.1 volatile的应用                                                              23
2.2 synchronized的实现原理与应用                                                29
2.2 synchronized的实现原理与应用                                                29
2.2.1 Java对象头                                                                30
2.2.1 Java对象头                                                                30
2.2.2 锁的升级与对比                                                            32
2.2.2 锁的升级与对比                                                            32
2.3 原子操作的实现原理                                                          37
2.3 原子操作的实现原理                                                          37
2.4 本章小结                                                                    43
2.4 本章小结                                                                    43
第3章 Java内存模型                                                              44
3.1.1 并发编程模型的两个关键问题                                                45
3.1.1 并发编程模型的两个关键问题                                                45
3.1 Java内存模型的基础                                                          45
3.1.2 Java内存模型的抽象结构                                                    46
3.1.2 Java内存模型的抽象结构                                                    46
3.1.3 从源代码到指令序列的重排序                                                50
3.1.3 从源代码到指令序列的重排序                                                50
3.1.4 并发编程模型的分类                                                        52
3.1.4 并发编程模型的分类                                                        52
3.1.5 happens-before简介                                                        58
3.1.5 happens-before简介                                                        58
3.2 重排序                                                                      60
3.2 重排序                                                                      60
3.2.1 数据依赖性                                                                61
3.2.1 数据依赖性                                                                61
3.2.2 as-if-serial语义                                                          62
3.2.2 as-if-serial语义                                                          62
3.2.3 程序顺序规则                                                              64
3.2.3 程序顺序规则                                                              64
3.2.4 重排序对多线程的影响                                                      65
3.2.4 重排序对多线程的影响                                                      65
3.3 顺序一致性                                                                  69
3.3 顺序一致性                                                                  69
3.3.1 数据竞争与顺序一致性                                                      70
3.3.1 数据竞争与顺序一致性                                                      70
3.3.2 顺序一致性内存模型                                                        71
3.3.2 顺序一致性内存模型                                                        71
3.3.3 同步程序的顺序一致性效果                                                  74
3.3.3 同步程序的顺序一致性效果                                                  74
3.3.4 未同步程序的执行特性                                                      76
3.3.4 未同步程序的执行特性                                                      76
3.4 volatile的内存语义                                                          81
3.4 volatile的内存语义                                                          81
3.4.1 volatile的特性                                                            82
3.4.1 volatile的特性                                                            82
3.4.2 volatile写-读建立的happens-before关系                                     84
3.4.2 volatile写-读建立的happens-before关系                                     84
3.4.3 volatile写-读的内存语义                                                   89
3.4.3 volatile写-读的内存语义                                                   89
3.4.4 volatile内存语义的实现                                                    93
3.4.4 volatile内存语义的实现                                                    93
3.4.5 JSR-133为什么要增强volatile的内存语义                                     101
3.4.5 JSR-133为什么要增强volatile的内存语义                                     101
3.5 锁的内存语义                                                                103
3.5 锁的内存语义                                                                103
3.5.1 锁的释放-获取建立的happens-before关系                                     104
3.5.1 锁的释放-获取建立的happens-before关系                                     104
3.5.2 锁的释放和获取的内存语义                                                  108
3.5.2 锁的释放和获取的内存语义                                                  108
3.5.3 锁内存语义的实现                                                          111
3.5.3 锁内存语义的实现                                                          111
3.5.4 concurrent包的实现                                                        122
3.5.4 concurrent包的实现                                                        122
3.6 final域的内存语义                                                           124
3.6 final域的内存语义                                                           124
3.6.1 final域的重排序规则                                                       125
3.6.1 final域的重排序规则                                                       125
3.6.2 写final域的重排序规则                                                     126
3.6.2 写final域的重排序规则                                                     126
3.6.3 读final域的重排序规则                                                     128
3.6.3 读final域的重排序规则                                                     128
3.6.4 final域为引用类型                                                         132
3.6.4 final域为引用类型                                                         132
3.6.5 为什么final引用不能从构造函数内“溢出”                                   134
3.6.5 为什么final引用不能从构造函数内“溢出”                                   134
3.6.6 final语义在处理器中的实现                                                 137
3.6.6 final语义在处理器中的实现                                                 137
3.6.7 JSR-133为什么要增强final的语义                                            138
3.6.7 JSR-133为什么要增强final的语义                                            138
3.7 happens-before                                                              139
3.7 happens-before                                                              139
3.7.1 JMM的设计                                                                 140
3.7.1 JMM的设计                                                                 140
3.7.2 happens-before的定义                                                      145
3.7.2 happens-before的定义                                                      145
3.7.3 happens-before规则                                                        148
3.7.3 happens-before规则                                                        148
3.8 双重检查锁定与延迟初始化                                                    154
3.8 双重检查锁定与延迟初始化                                                    154
3.8.1 双重检查锁定的由来                                                        155
3.8.1 双重检查锁定的由来                                                        155
3.8.2 问题的根源                                                                158
3.8.2 问题的根源                                                                158
3.8.3 基于volatile的解决方案                                                    162
3.8.3 基于volatile的解决方案                                                    162
3.8.4 基于类初始化的解决方案                                                    164
3.8.4 基于类初始化的解决方案                                                    164
3.9 Java内存模型综述                                                            175
3.9 Java内存模型综述                                                            175
3.9.1 处理器的内存模型                                                          176
3.9.1 处理器的内存模型                                                          176
3.9.2 各种内存模型之间的关系                                                    179
3.9.2 各种内存模型之间的关系                                                    179
3.9.3 JMM的内存可见性保证                                                       180
3.9.3 JMM的内存可见性保证                                                       180
3.9.4 JSR-133对旧内存模型的修补                                                 183
3.9.4 JSR-133对旧内存模型的修补                                                 183
3.10 本章小结                                                                   185
第4章 Java并发编程基础                                                          186
4.1 线程简介                                                                    187
4.1.1 什么是线程                                                                187
4.1.1 什么是线程                                                                187
4.1.2 为什么要使用多线程                                                        189
4.1.2 为什么要使用多线程                                                        189
4.1.3 线程优先级                                                                191
4.1.3 线程优先级                                                                191
4.1.4 线程的状态                                                                193
4.1.4 线程的状态                                                                193
4.1.5 Daemon线程                                                                197
4.1.5 Daemon线程                                                                197
4.2 启动和终止线程                                                              199
4.2 启动和终止线程                                                              199
4.2.1 构造线程                                                                  200
4.2.1 构造线程                                                                  200
4.2.2 启动线程                                                                  201
4.2.2 启动线程                                                                  201
4.2.3 理解中断                                                                  202
4.2.3 理解中断                                                                  202
4.2.4 过期的suspend()、resume()和stop()                                         205
4.2.4 过期的suspend()、resume()和stop()                                         205
4.2.5 安全地终止线程                                                            207
4.2.5 安全地终止线程                                                            207
4.3 线程间通信                                                                  209
4.3 线程间通信                                                                  209
4.3.1 volatile和synchronized关键字                                              210
4.3.1 volatile和synchronized关键字                                              210
4.3.2 等待/通知机制                                                             213
4.3.2 等待/通知机制                                                             213
4.3.3 等待/通知的经典范式                                                       218
4.3.3 等待/通知的经典范式                                                       218
4.3.4 管道输入/输出流                                                           220
4.3.4 管道输入/输出流                                                           220
4.3.5 Thread.join()的使用                                                       222
4.3.5 Thread.join()的使用                                                       222
4.3.6 ThreadLocal的使用                                                         224
4.3.6 ThreadLocal的使用                                                         224
4.4.1 等待超时模式                                                              227
4.4 线程应用实例                                                                227
4.4.1 等待超时模式                                                              227
4.4.2 一个简单的数据库连接池示例                                                229
4.4.2 一个简单的数据库连接池示例                                                229
4.4.3 线程池技术及其示例                                                        235
4.4.3 线程池技术及其示例                                                        235
4.4.4 一个基于线程池技术的简单Web服务器                                         240
4.4.4 一个基于线程池技术的简单Web服务器                                         240
4.5 本章小结                                                                    245
4.5 本章小结                                                                    245
第5章 Java中的锁                                                                246
5.1 Lock接口                                                                    247
5.1 Lock接口                                                                    247
5.2 队列同步器                                                                  249
5.2 队列同步器                                                                  249
5.2.1 队列同步器的接口与示例                                                    250
5.2.1 队列同步器的接口与示例                                                    250
5.2.2 队列同步器的实现分析                                                      257
5.2.2 队列同步器的实现分析                                                      257
5.3 重入锁                                                                      279
5.3 重入锁                                                                      279
5.4 读写锁                                                                      285
5.4 读写锁                                                                      285
5.4.1 读写锁的接口与示例                                                        287
5.4.1 读写锁的接口与示例                                                        287
5.4.2 读写锁的实现分析                                                          289
5.4.2 读写锁的实现分析                                                          289
5.5 LockSupport工具                                                             295
5.5 LockSupport工具                                                             295
5.6 Condition接口                                                               297
5.6 Condition接口                                                               297
5.6.1 Condition接口与示例                                                       298
5.6.1 Condition接口与示例                                                       298
5.6.2 Condition的实现分析                                                       301
5.6.2 Condition的实现分析                                                       301
5.7 本章小结                                                                    306
第6章 Java并发容器和框架                                                        307
6.1 ConcurrentHashMap的实现原理与使用                                           308
6.1 ConcurrentHashMap的实现原理与使用                                           308
6.1.1 为什么要使用ConcurrentHashMap                                             309
6.1.1 为什么要使用ConcurrentHashMap                                             309
6.1.2 ConcurrentHashMap的结构                                                   311
6.1.2 ConcurrentHashMap的结构                                                   311
6.1.3 ConcurrentHashMap的初始化                                                 313
6.1.3 ConcurrentHashMap的初始化                                                 313
6.1.4 定位Segment                                                               316
6.1.4 定位Segment                                                               316
6.1.5 ConcurrentHashMap的操作                                                   318
6.1.5 ConcurrentHashMap的操作                                                   318
6.2 ConcurrentLinkedQueue                                                       322
6.2 ConcurrentLinkedQueue                                                       322
6.2.1 ConcurrentLinkedQueue的结构                                               323
6.2.1 ConcurrentLinkedQueue的结构                                               323
6.2.2 入队列                                                                    324
6.2.2 入队列                                                                    324
6.2.3 出队列                                                                    331
6.2.3 出队列                                                                    331
6.3 Java中的阻塞队列                                                            333
6.3 Java中的阻塞队列                                                            333
6.3.1 什么是阻塞队列                                                            334
6.3.1 什么是阻塞队列                                                            334
6.3.2 Java里的阻塞队列                                                          337
6.3.2 Java里的阻塞队列                                                          337
6.3.3 阻塞队列的实现原理                                                        344
6.3.3 阻塞队列的实现原理                                                        344
6.4 Fork/Join框架                                                               349
6.4 Fork/Join框架                                                               349
6.4.1 什么是Fork/Join框架                                                       350
6.4.1 什么是Fork/Join框架                                                       350
6.4.2 工作窃取算法                                                              352
6.4.2 工作窃取算法                                                              352
6.4.3 Fork/Join框架的设计                                                       354
6.4.3 Fork/Join框架的设计                                                       354
6.4.4 使用Fork/Join框架                                                         355
6.4.4 使用Fork/Join框架                                                         355
6.4.5 Fork/Join框架的异常处理                                                   357
6.4.5 Fork/Join框架的异常处理                                                   357
6.4.6 Fork/Join框架的实现原理                                                   358
6.4.6 Fork/Join框架的实现原理                                                   358
6.5 本章小结                                                                    361
6.5 本章小结                                                                    361
第7章 Java中的13个原子操作类                                                    362
7.1 原子更新基本类型类                                                          363
7.1 原子更新基本类型类                                                          363
7.2 原子更新数组                                                                367
7.2 原子更新数组                                                                367
7.3 原子更新引用类型                                                            369
7.3 原子更新引用类型                                                            369
7.4 原子更新字段类                                                              371
7.4 原子更新字段类                                                              371
7.5 本章小结                                                                    373
7.5 本章小结                                                                    373
第8章 Java中的并发工具类                                                        374
8.1 等待多线程完成的CountDownLatch                                              375
8.1 等待多线程完成的CountDownLatch                                              375
8.2 同步屏障CyclicBarrier                                                       378
8.2 同步屏障CyclicBarrier                                                       378
8.2.1 CyclicBarrier简介                                                         379
8.2.1 CyclicBarrier简介                                                         379
8.2.2 CyclicBarrier的应用场景                                                   383
8.2.2 CyclicBarrier的应用场景                                                   383
8.2.3 CyclicBarrier和CountDownLatch的区别                                       385
8.2.3 CyclicBarrier和CountDownLatch的区别                                       385
8.3 控制并发线程数的Semaphore                                                   387
8.3 控制并发线程数的Semaphore                                                   387
8.4 线程间交换数据的Exchanger                                                   389
8.4 线程间交换数据的Exchanger                                                   389
8.5 本章小结                                                                    391
8.5 本章小结                                                                    391
第9章 Java中的线程池                                                            392
9.1 线程池的实现原理                                                            393
9.1 线程池的实现原理                                                            393
9.2.1 线程池的创建                                                              401
9.2 线程池的使用                                                                401
9.2.1 线程池的创建                                                              401
9.2.2 向线程池提交任务                                                          405
9.2.2 向线程池提交任务                                                          405
9.2.3 关闭线程池                                                                406
9.2.3 关闭线程池                                                                406
9.2.4 合理地配置线程池                                                          407
9.2.4 合理地配置线程池                                                          407
9.2.5 线程池的监控                                                              409
9.2.5 线程池的监控                                                              409
9.3 本章小结                                                                    410
第10章 Executor框架                                                             411
10.1.1 Executor框架的两级调度模型                                               412
10.1 Executor框架简介                                                           412
10.1.1 Executor框架的两级调度模型                                               412
10.1.2 Executor框架的结构与成员                                                 413
10.1.2 Executor框架的结构与成员                                                 413
10.2 ThreadPoolExecutor详解                                                     422
10.2 ThreadPoolExecutor详解                                                     422
10.2.1 FixedThreadPool详解                                                      423
10.2.1 FixedThreadPool详解                                                      423
10.2.2 SingleThreadExecutor详解                                                 426
10.2.2 SingleThreadExecutor详解                                                 426
10.2.3 CachedThreadPool详解                                                     428
10.2.3 CachedThreadPool详解                                                     428
10.3 ScheduledThreadPoolExecutor详解                                            432
10.3 ScheduledThreadPoolExecutor详解                                            432
10.3.1 ScheduledThreadPoolExecutor的运行机制                                    433
10.3.1 ScheduledThreadPoolExecutor的运行机制                                    433
10.3.2 ScheduledThreadPoolExecutor的实现                                        435
10.3.2 ScheduledThreadPoolExecutor的实现                                        435
10.4 FutureTask详解                                                             442
10.4 FutureTask详解                                                             442
10.4.1 FutureTask简介                                                           443
10.4.1 FutureTask简介                                                           443
10.4.2 FutureTask的使用                                                         446
10.4.2 FutureTask的使用                                                         446
10.4.3 FutureTask的实现                                                         448
10.4.3 FutureTask的实现                                                         448
10.5 本章小结                                                                   453
第11章 Java并发编程实践                                                         454
11.1 生产者和消费者模式                                                         455
11.1 生产者和消费者模式                                                         455
11.1.1 生产者消费者模式实战                                                     456
11.1.1 生产者消费者模式实战                                                     456
11.1.2 多生产者和多消费者场景                                                   459
11.1.2 多生产者和多消费者场景                                                   459
11.1.3 线程池与生产消费者模式                                                   463
11.1.3 线程池与生产消费者模式                                                   463
11.2 线上问题定位                                                               464
11.2 线上问题定位                                                               464
11.3 性能测试                                                                   467
11.3 性能测试                                                                   467
11.4 异步任务池                                                                 470
11.4 异步任务池                                                                 470
11.5 本章小结                                                                   473
11.5 本章小结                                                                   473